import { Blueprint, GenerationOutput, ValidationResult } from '../types';
import { logger } from '../utils/logger';
import yaml from 'js-yaml';

export class CloudFormationGenerator {
  async generate(blueprint: Blueprint, options: any = {}): Promise<GenerationOutput> {
    logger.info('Generating CloudFormation code', { blueprintId: blueprint.id });

    const template: any = {
      AWSTemplateFormatVersion: '2010-09-09',
      Description: `Generated by IAC DHARMA - Blueprint: ${blueprint.name}`,
      Metadata: {
        GeneratedAt: new Date().toISOString(),
        BlueprintId: blueprint.id
      },
      Parameters: this.generateParameters(blueprint),
      Resources: {},
      Outputs: {}
    };

    // Generate resources from components
    for (const component of blueprint.components) {
      const resourceName = this.sanitizeName(component.name);
      const resource = this.generateResource(component);
      if (resource) {
        template.Resources[resourceName] = resource;
      }
    }

    // Generate outputs
    template.Outputs = this.generateOutputs(blueprint);

    // Convert to YAML (CloudFormation standard)
    const code = yaml.dump(template, {
      indent: 2,
      lineWidth: 120,
      noRefs: true
    });

    return {
      code,
      files: [
        { name: 'template.yaml', content: code, type: 'main' }
      ],
      metadata: {
        resourceCount: blueprint.components.length,
        warnings: []
      }
    };
  }

  private generateResource(component: any): any {
    const resourceType = this.mapToCloudFormationResource(component.type, component.provider);
    
    return {
      Type: resourceType,
      Properties: this.formatProperties(component.properties, component.type)
    };
  }

  private mapToCloudFormationResource(type: string, provider: string): string {
    // If provider is already CloudFormation format, use it
    if (provider.startsWith('AWS::')) {
      return provider;
    }

    // Map generic types to AWS resource types
    const mappings: Record<string, string> = {
      'compute': 'AWS::EC2::Instance',
      'network': 'AWS::EC2::VPC',
      'storage': 'AWS::S3::Bucket',
      'database': 'AWS::RDS::DBInstance',
      'lambda': 'AWS::Lambda::Function',
      'api_gateway': 'AWS::ApiGateway::RestApi',
      'dynamodb': 'AWS::DynamoDB::Table',
      'sqs': 'AWS::SQS::Queue',
      'sns': 'AWS::SNS::Topic',
      'ecs': 'AWS::ECS::Service'
    };

    return mappings[type] || provider;
  }

  private formatProperties(properties: Record<string, any>, componentType: string): any {
    const formatted: Record<string, any> = {};

    for (const [key, value] of Object.entries(properties)) {
      // Convert property names to CloudFormation convention (PascalCase)
      const cfKey = this.toPascalCase(key);
      
      if (typeof value === 'object' && !Array.isArray(value)) {
        formatted[cfKey] = this.formatProperties(value, componentType);
      } else {
        formatted[cfKey] = value;
      }
    }

    return formatted;
  }

  private toPascalCase(str: string): string {
    return str
      .split('_')
      .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
      .join('');
  }

  private generateParameters(blueprint: Blueprint): any {
    return {
      Environment: {
        Type: 'String',
        Default: 'dev',
        AllowedValues: ['dev', 'staging', 'production'],
        Description: 'Environment name'
      },
      ProjectName: {
        Type: 'String',
        Default: blueprint.name,
        Description: 'Project name'
      }
    };
  }

  private generateOutputs(blueprint: Blueprint): any {
    const outputs: any = {};

    for (const component of blueprint.components) {
      const resourceName = this.sanitizeName(component.name);
      
      outputs[`${resourceName}Id`] = {
        Description: `ID of ${component.name}`,
        Value: { Ref: resourceName },
        Export: {
          Name: { 'Fn::Sub': `\${AWS::StackName}-${resourceName}-Id` }
        }
      };
    }

    return outputs;
  }

  private sanitizeName(name: string): string {
    // CloudFormation logical names must be alphanumeric
    return name
      .split(/[^a-zA-Z0-9]/)
      .map(word => word.charAt(0).toUpperCase() + word.slice(1))
      .join('');
  }

  async validate(code: string): Promise<ValidationResult> {
    const errors: string[] = [];
    const warnings: string[] = [];

    try {
      // Parse YAML
      const template = yaml.load(code) as any;

      // Check required fields
      if (!template.AWSTemplateFormatVersion) {
        errors.push('Missing AWSTemplateFormatVersion');
      }

      if (!template.Resources || Object.keys(template.Resources).length === 0) {
        errors.push('No resources defined');
      }

      // Validate resource types
      if (template.Resources) {
        for (const [name, resource] of Object.entries(template.Resources)) {
          const res = resource as any;
          if (!res.Type || !res.Type.startsWith('AWS::')) {
            errors.push(`Invalid resource type for ${name}: ${res.Type}`);
          }
        }
      }

      // Check for security best practices
      if (code.includes('Password') && !code.includes('NoEcho')) {
        warnings.push('Sensitive parameters should use NoEcho: true');
      }

    } catch (error: any) {
      errors.push(`YAML parsing error: ${error.message}`);
    }

    return {
      valid: errors.length === 0,
      errors: errors.length > 0 ? errors : undefined,
      warnings: warnings.length > 0 ? warnings : undefined
    };
  }

  getSupportedResources(): string[] {
    return [
      'AWS::EC2::Instance',
      'AWS::EC2::VPC',
      'AWS::S3::Bucket',
      'AWS::RDS::DBInstance',
      'AWS::Lambda::Function',
      'AWS::ApiGateway::RestApi',
      'AWS::DynamoDB::Table',
      'AWS::SQS::Queue',
      'AWS::SNS::Topic',
      'AWS::ECS::Service',
      'AWS::ECS::TaskDefinition',
      'AWS::ElasticLoadBalancingV2::LoadBalancer',
      'AWS::IAM::Role',
      'AWS::CloudWatch::Alarm'
    ];
  }
}
