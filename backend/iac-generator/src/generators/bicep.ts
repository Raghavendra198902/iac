import { Blueprint, GenerationOutput, ValidationResult } from '../types';
import { logger } from '../utils/logger';

export class BicepGenerator {
  async generate(blueprint: Blueprint, options: any = {}): Promise<GenerationOutput> {
    logger.info('Generating Bicep code', { blueprintId: blueprint.id });

    const parameters: string[] = [];
    const resources: string[] = [];
    const outputs: string[] = [];

    // Add metadata
    const metadata = [
      `// Generated by IAC DHARMA`,
      `// Blueprint: ${blueprint.name}`,
      `// Generated: ${new Date().toISOString()}`,
      '',
      `targetScope = 'resourceGroup'`,
      ''
    ];

    // Generate parameters
    parameters.push(this.generateParameters(blueprint));

    // Generate resources from components
    for (const component of blueprint.components) {
      const resource = this.generateResource(component);
      if (resource) {
        resources.push(resource);
      }
    }

    // Generate outputs
    outputs.push(this.generateOutputs(blueprint));

    const code = [
      ...metadata,
      ...parameters,
      '',
      ...resources,
      '',
      ...outputs
    ].join('\n');

    return {
      code,
      files: [
        { name: 'main.bicep', content: code, type: 'main' }
      ],
      metadata: {
        resourceCount: blueprint.components.length,
        warnings: []
      }
    };
  }

  private generateResource(component: any): string {
    const resourceType = this.mapToBicepResource(component.type, component.provider);
    const resourceName = this.sanitizeName(component.name);
    const apiVersion = this.getApiVersion(resourceType);

    const properties = this.formatProperties(component.properties, 1);

    return `resource ${resourceName} '${resourceType}@${apiVersion}' = {
  name: '${component.name}'
  location: location
${properties}
}`;
  }

  private mapToBicepResource(type: string, provider: string): string {
    // If provider is already Bicep format, use it
    if (provider.includes('/')) {
      return provider;
    }

    // Map generic types to Azure resource types
    const mappings: Record<string, string> = {
      'compute': 'Microsoft.Compute/virtualMachines',
      'network': 'Microsoft.Network/virtualNetworks',
      'storage': 'Microsoft.Storage/storageAccounts',
      'database': 'Microsoft.DBforPostgreSQL/servers',
      'app_service': 'Microsoft.Web/sites',
      'aks': 'Microsoft.ContainerService/managedClusters',
      'sql': 'Microsoft.Sql/servers'
    };

    return mappings[type] || provider;
  }

  private getApiVersion(resourceType: string): string {
    const versions: Record<string, string> = {
      'Microsoft.Compute/virtualMachines': '2023-03-01',
      'Microsoft.Network/virtualNetworks': '2023-04-01',
      'Microsoft.Storage/storageAccounts': '2023-01-01',
      'Microsoft.DBforPostgreSQL/servers': '2022-12-01',
      'Microsoft.Web/sites': '2023-01-01',
      'Microsoft.ContainerService/managedClusters': '2023-07-01',
      'Microsoft.Sql/servers': '2023-02-01-preview'
    };

    return versions[resourceType] || '2023-01-01';
  }

  private formatProperties(properties: Record<string, any>, indent: number): string {
    const indentStr = '  '.repeat(indent);
    const lines: string[] = [];

    if (Object.keys(properties).length === 0) {
      return '';
    }

    lines.push(`${indentStr}properties: {`);

    for (const [key, value] of Object.entries(properties)) {
      if (typeof value === 'object' && !Array.isArray(value)) {
        lines.push(`${indentStr}  ${key}: {`);
        lines.push(this.formatNestedProperties(value, indent + 2));
        lines.push(`${indentStr}  }`);
      } else if (Array.isArray(value)) {
        lines.push(`${indentStr}  ${key}: ${JSON.stringify(value)}`);
      } else if (typeof value === 'string') {
        lines.push(`${indentStr}  ${key}: '${value}'`);
      } else {
        lines.push(`${indentStr}  ${key}: ${value}`);
      }
    }

    lines.push(`${indentStr}}`);
    return lines.join('\n');
  }

  private formatNestedProperties(properties: Record<string, any>, indent: number): string {
    const indentStr = '  '.repeat(indent);
    const lines: string[] = [];

    for (const [key, value] of Object.entries(properties)) {
      if (typeof value === 'string') {
        lines.push(`${indentStr}${key}: '${value}'`);
      } else {
        lines.push(`${indentStr}${key}: ${JSON.stringify(value)}`);
      }
    }

    return lines.join('\n');
  }

  private generateParameters(blueprint: Blueprint): string {
    const params: string[] = [];

    params.push(`param location string = 'eastus'`);
    params.push(`param environment string = 'dev'`);
    params.push(`param tags object = {
  environment: environment
  blueprint: '${blueprint.name}'
  managedBy: 'IAC-DHARMA'
}`);

    return params.join('\n');
  }

  private generateOutputs(blueprint: Blueprint): string {
    const outputs: string[] = [];

    for (const component of blueprint.components) {
      const resourceName = this.sanitizeName(component.name);
      
      outputs.push(`output ${resourceName}Id string = ${resourceName}.id`);
      outputs.push(`output ${resourceName}Name string = ${resourceName}.name`);
    }

    return outputs.join('\n');
  }

  private sanitizeName(name: string): string {
    // Bicep names must start with letter and contain only alphanumerics
    const sanitized = name.replace(/[^a-zA-Z0-9]/g, '');
    return sanitized.charAt(0).toLowerCase() + sanitized.slice(1);
  }

  async validate(code: string): Promise<ValidationResult> {
    const errors: string[] = [];
    const warnings: string[] = [];

    // Basic syntax validation
    if (!code.includes('resource')) {
      errors.push('No resources defined');
    }

    // Check for targetScope
    if (!code.includes('targetScope')) {
      warnings.push('No targetScope defined, defaulting to resourceGroup');
    }

    // Check for location
    if (code.includes('resource') && !code.includes('location')) {
      warnings.push('Resources should specify a location');
    }

    return {
      valid: errors.length === 0,
      errors: errors.length > 0 ? errors : undefined,
      warnings: warnings.length > 0 ? warnings : undefined
    };
  }

  getSupportedResources(): string[] {
    return [
      'Microsoft.Compute/virtualMachines',
      'Microsoft.Network/virtualNetworks',
      'Microsoft.Storage/storageAccounts',
      'Microsoft.DBforPostgreSQL/servers',
      'Microsoft.Web/sites',
      'Microsoft.ContainerService/managedClusters',
      'Microsoft.Sql/servers',
      'Microsoft.KeyVault/vaults',
      'Microsoft.Network/loadBalancers',
      'Microsoft.Network/applicationGateways'
    ];
  }
}
