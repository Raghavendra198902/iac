import { Blueprint, GenerationOutput, ValidationResult } from '../types';
import { logger } from '../utils/logger';

export class TerraformGenerator {
  async generate(blueprint: Blueprint, options: any = {}): Promise<GenerationOutput> {
    logger.info('Generating Terraform code', { blueprintId: blueprint.id });

    const resources: string[] = [];
    const variables: string[] = [];
    const outputs: string[] = [];

    // Add provider configuration
    const provider = this.getProvider(blueprint.target_cloud);
    resources.push(provider);

    // Generate resources from components
    for (const component of blueprint.components) {
      const resource = this.generateResource(component, blueprint.target_cloud);
      if (resource) {
        resources.push(resource);
      }
    }

    // Generate variables
    variables.push(this.generateVariables(blueprint));

    // Generate outputs
    outputs.push(this.generateOutputs(blueprint));

    const code = [
      '# Generated by IAC DHARMA',
      `# Blueprint: ${blueprint.name}`,
      `# Generated: ${new Date().toISOString()}`,
      '',
      ...resources,
      '',
      ...variables,
      '',
      ...outputs
    ].join('\n');

    return {
      code,
      files: [
        { name: 'main.tf', content: resources.join('\n\n'), type: 'main' },
        { name: 'variables.tf', content: variables.join('\n\n'), type: 'variables' },
        { name: 'outputs.tf', content: outputs.join('\n\n'), type: 'outputs' }
      ],
      metadata: {
        resourceCount: blueprint.components.length,
        warnings: []
      }
    };
  }

  private getProvider(cloud: string): string {
    switch (cloud) {
      case 'azure':
        return `terraform {
  required_providers {
    azurerm = {
      source  = "hashicorp/azurerm"
      version = "~> 3.0"
    }
  }
}

provider "azurerm" {
  features {}
}`;
      case 'aws':
        return `terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}

provider "aws" {
  region = var.aws_region
}`;
      case 'gcp':
        return `terraform {
  required_providers {
    google = {
      source  = "hashicorp/google"
      version = "~> 5.0"
    }
  }
}

provider "google" {
  project = var.gcp_project
  region  = var.gcp_region
}`;
      default:
        return '# Provider configuration';
    }
  }

  private generateResource(component: any, cloud: string): string {
    const resourceType = this.mapToTerraformResource(component.type, component.provider, cloud);
    const resourceName = this.sanitizeName(component.name);

    const properties = this.formatProperties(component.properties, 1);

    return `resource "${resourceType}" "${resourceName}" {
${properties}
}`;
  }

  private mapToTerraformResource(type: string, provider: string, cloud: string): string {
    // If provider is already terraform format, use it
    if (provider.includes('_')) {
      return provider;
    }

    // Map generic types to cloud-specific resources
    const mappings: Record<string, Record<string, string>> = {
      azure: {
        'compute': 'azurerm_linux_virtual_machine',
        'network': 'azurerm_virtual_network',
        'storage': 'azurerm_storage_account',
        'database': 'azurerm_postgresql_server'
      },
      aws: {
        'compute': 'aws_instance',
        'network': 'aws_vpc',
        'storage': 'aws_s3_bucket',
        'database': 'aws_db_instance'
      },
      gcp: {
        'compute': 'google_compute_instance',
        'network': 'google_compute_network',
        'storage': 'google_storage_bucket',
        'database': 'google_sql_database_instance'
      }
    };

    return mappings[cloud]?.[type] || provider;
  }

  private formatProperties(properties: Record<string, any>, indent: number): string {
    const indentStr = '  '.repeat(indent);
    const lines: string[] = [];

    for (const [key, value] of Object.entries(properties)) {
      if (typeof value === 'object' && !Array.isArray(value)) {
        lines.push(`${indentStr}${key} {`);
        lines.push(this.formatProperties(value, indent + 1));
        lines.push(`${indentStr}}`);
      } else if (Array.isArray(value)) {
        lines.push(`${indentStr}${key} = ${JSON.stringify(value)}`);
      } else if (typeof value === 'string') {
        lines.push(`${indentStr}${key} = "${value}"`);
      } else {
        lines.push(`${indentStr}${key} = ${value}`);
      }
    }

    return lines.join('\n');
  }

  private generateVariables(blueprint: Blueprint): string {
    const vars: string[] = [];

    if (blueprint.target_cloud === 'azure') {
      vars.push(`variable "location" {
  description = "Azure region"
  type        = string
  default     = "eastus"
}`);
    } else if (blueprint.target_cloud === 'aws') {
      vars.push(`variable "aws_region" {
  description = "AWS region"
  type        = string
  default     = "us-east-1"
}`);
    }

    vars.push(`variable "environment" {
  description = "Environment name"
  type        = string
  default     = "dev"
}`);

    return vars.join('\n\n');
  }

  private generateOutputs(blueprint: Blueprint): string {
    const outputs: string[] = [];

    for (const component of blueprint.components) {
      const resourceType = this.mapToTerraformResource(component.type, component.provider, blueprint.target_cloud);
      const resourceName = this.sanitizeName(component.name);
      
      outputs.push(`output "${resourceName}_id" {
  description = "ID of ${component.name}"
  value       = ${resourceType}.${resourceName}.id
}`);
    }

    return outputs.join('\n\n');
  }

  private sanitizeName(name: string): string {
    return name.toLowerCase().replace(/[^a-z0-9_]/g, '_');
  }

  async validate(code: string): Promise<ValidationResult> {
    const errors: string[] = [];
    const warnings: string[] = [];

    // Basic syntax validation
    if (!code.includes('provider')) {
      warnings.push('No provider configuration found');
    }

    if (!code.includes('resource')) {
      errors.push('No resources defined');
    }

    // Check for common issues
    if (code.includes('password') && !code.includes('sensitive')) {
      warnings.push('Sensitive values should be marked as sensitive');
    }

    return {
      valid: errors.length === 0,
      errors: errors.length > 0 ? errors : undefined,
      warnings: warnings.length > 0 ? warnings : undefined
    };
  }

  getSupportedResources(): string[] {
    return [
      'azurerm_linux_virtual_machine',
      'azurerm_virtual_network',
      'azurerm_storage_account',
      'azurerm_postgresql_server',
      'aws_instance',
      'aws_vpc',
      'aws_s3_bucket',
      'aws_db_instance',
      'google_compute_instance',
      'google_compute_network',
      'google_storage_bucket',
      'google_sql_database_instance'
    ];
  }
}
