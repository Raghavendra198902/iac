import express, { Application, Request, Response, NextFunction } from 'express';
import helmet from 'helmet';















































































































































































































































































































export default AgentsPage;};  );    </Container>      </Card>        </CardContent>          )}            </TableContainer>              </Table>                </TableBody>                  ))}                    </TableRow>                      </TableCell>                        </Typography>                          {agent.eventCounts.suspicious_process}                        >                          fontWeight={agent.eventCounts.suspicious_process > 0 ? 'bold' : 'normal'}                          color={agent.eventCounts.suspicious_process > 0 ? 'error.main' : 'text.primary'}                          variant="body2"                        <Typography                      <TableCell align="right">                      <TableCell align="right">{agent.eventCounts.process_stop}</TableCell>                      <TableCell align="right">{agent.eventCounts.process_start}</TableCell>                      </TableCell>                        </Typography>                          {agent.totalEvents.toLocaleString()}                        <Typography variant="body2" fontWeight="medium">                      <TableCell align="right">                      </TableCell>                        </Typography>                          {new Date(agent.lastSeen).toLocaleString()}                        <Typography variant="caption" color="text.secondary">                        <Typography variant="body2">{agent.uptime}</Typography>                      <TableCell>                      </TableCell>                        )}                          </Typography>                            Org: {agent.organizationId}                          <Typography variant="caption" color="text.secondary">                        {agent.organizationId && (                        </Typography>                          {agent.agentName}                        <Typography variant="body2" fontWeight="medium">                      <TableCell>                      </TableCell>                        />                          size="small"                          color={getStatusColor(agent.status)}                          label={agent.status.toUpperCase()}                          icon={getStatusIcon(agent.status)}                        <Chip                      <TableCell>                    <TableRow key={agent.agentName} hover>                  {agents.map((agent) => (                <TableBody>                </TableHead>                  </TableRow>                    <TableCell align="right">Suspicious</TableCell>                    <TableCell align="right">Process Stops</TableCell>                    <TableCell align="right">Process Starts</TableCell>                    <TableCell align="right">Total Events</TableCell>                    <TableCell>Last Seen</TableCell>                    <TableCell>Agent Name</TableCell>                    <TableCell>Status</TableCell>                  <TableRow>                <TableHead>              <Table>            <TableContainer component={Paper} elevation={0}>          ) : (            <Alert severity="info">No agents registered yet. Deploy an agent to see it here.</Alert>          {agents.length === 0 ? (          </Typography>            Registered Agents          <Typography variant="h5" gutterBottom>        <CardContent>      <Card>      {/* Agents Table */}      )}        </Grid>          </Grid>            </Card>              </CardContent>                </Box>                  <WarningIcon sx={{ fontSize: 48, color: 'error.main', opacity: 0.3 }} />                  </Box>                    </Typography>                      {summary.totalSuspicious}                    <Typography variant="h4" color={summary.totalSuspicious > 0 ? 'error.main' : 'text.primary'}>                    </Typography>                      Suspicious                    <Typography color="text.secondary" gutterBottom variant="overline">                  <Box>                <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>              <CardContent>            <Card>          <Grid item xs={12} sm={6} md={3}>          </Grid>            </Card>              </CardContent>                </Box>                  <TimelineIcon sx={{ fontSize: 48, color: 'info.main', opacity: 0.3 }} />                  </Box>                    <Typography variant="h4">{summary.totalEvents.toLocaleString()}</Typography>                    </Typography>                      Total Events                    <Typography color="text.secondary" gutterBottom variant="overline">                  <Box>                <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>              <CardContent>            <Card>          <Grid item xs={12} sm={6} md={3}>          </Grid>            </Card>              </CardContent>                </Box>                  <OnlineIcon sx={{ fontSize: 48, color: 'success.main', opacity: 0.3 }} />                  </Box>                    </Typography>                      {summary.onlineAgents}                    <Typography variant="h4" color="success.main">                    </Typography>                      Online                    <Typography color="text.secondary" gutterBottom variant="overline">                  <Box>                <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>              <CardContent>            <Card>          <Grid item xs={12} sm={6} md={3}>          </Grid>            </Card>              </CardContent>                </Box>                  <ComputerIcon sx={{ fontSize: 48, color: 'primary.main', opacity: 0.3 }} />                  </Box>                    <Typography variant="h4">{summary.totalAgents}</Typography>                    </Typography>                      Total Agents                    <Typography color="text.secondary" gutterBottom variant="overline">                  <Box>                <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>              <CardContent>            <Card>          <Grid item xs={12} sm={6} md={3}>        <Grid container spacing={3} sx={{ mb: 4 }}>      {summary && (      {/* Summary Cards */}      )}        </Alert>          {error}        <Alert severity="error" sx={{ mb: 3 }}>      {error && (      </Box>        </Tooltip>          </IconButton>            <RefreshIcon />          <IconButton onClick={fetchData} color="primary">        <Tooltip title={autoRefresh ? 'Auto-refresh enabled' : 'Click to refresh'}>        </Box>          </Typography>            Monitor and manage CMDB agents in real-time          <Typography variant="subtitle1" color="text.secondary">          </Typography>            Agent Management          <Typography variant="h3" gutterBottom>        <Box>      <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 4 }}>      {/* Header */}    <Container maxWidth="lg" sx={{ mt: 4, mb: 4 }}>  return (  }    );      </Container>        <Typography sx={{ mt: 2 }}>Loading agent data...</Typography>        <CircularProgress />      <Container maxWidth="lg" sx={{ mt: 4, mb: 4, textAlign: 'center' }}>    return (  if (loading && agents.length === 0) {  };    }      default: return 'default';      case 'offline': return 'error';      case 'warning': return 'warning';      case 'online': return 'success';    switch (status) {  const getStatusColor = (status: string): 'success' | 'warning' | 'error' | 'default' => {  };    }        return <ComputerIcon />;      default:        return <OfflineIcon sx={{ color: 'error.main' }} />;      case 'offline':        return <WarningIcon sx={{ color: 'warning.main' }} />;      case 'warning':        return <OnlineIcon sx={{ color: 'success.main' }} />;      case 'online':    switch (status) {  const getStatusIcon = (status: string) => {  };    }      setLoading(false);      setError(err?.message || 'Failed to fetch agent data');      console.error('Error fetching agent data:', err);    } catch (err: any) {      setError(null);      setLoading(false);      setSummary(summaryData.summary);      setAgents(agentsData.agents || []);      const summaryData = await summaryRes.json();      if (!summaryRes.ok) throw new Error('Failed to fetch summary');      const summaryRes = await fetch(`${apiBaseUrl}/agents/stats/summary`);      // Fetch summary stats      const agentsData = await agentsRes.json();      if (!agentsRes.ok) throw new Error('Failed to fetch agents');      const agentsRes = await fetch(`${apiBaseUrl}/agents`);      // Fetch agents list            const apiBaseUrl = `http://${window.location.hostname}:3000/api`;    try {  const fetchData = async () => {  }, [autoRefresh]);    }      return () => clearInterval(interval);      const interval = setInterval(fetchData, 5000); // Refresh every 5 seconds    if (autoRefresh) {    fetchData();  useEffect(() => {  const [autoRefresh, setAutoRefresh] = useState(true);  const [error, setError] = useState<string | null>(null);  const [loading, setLoading] = useState(true);  const [summary, setSummary] = useState<AgentSummary | null>(null);  const [agents, setAgents] = useState<AgentData[]>([]);const AgentsPage: React.FC = () => {}  totalSuspicious: number;  totalProcessStops: number;  totalProcessStarts: number;  totalEvents: number;  offlineAgents: number;  warningAgents: number;  onlineAgents: number;  totalAgents: number;interface AgentSummary {}  uptime: string;  };    heartbeat: number;    suspicious_process: number;    process_stop: number;    process_start: number;  eventCounts: {  totalEvents: number;  status: 'online' | 'offline' | 'warning';  lastSeen: string;  organizationId?: string;  agentName: string;interface AgentData {} from '@mui/icons-material';  Timeline as TimelineIcon,  Refresh as RefreshIcon,  Cancel as OfflineIcon,  Warning as WarningIcon,  CheckCircle as OnlineIcon,  Computer as ComputerIcon,import {} from '@mui/material';  Tooltip,  IconButton,  Paper,  TableRow,  TableHead,  TableContainer,  TableCell,  TableBody,  Table,  Alert,  CircularProgress,  Chip,  Box,  Grid,  CardContent,  Card,  Typography,  Container,import cors from 'cors';
import rateLimit from 'express-rate-limit';
import morgan from 'morgan';
import { logger } from './utils/logger';
import { errorHandler } from './middleware/errorHandler';
import { authMiddleware } from './middleware/auth';
import { performanceMiddleware } from './utils/performance';
import routes from './routes';
import { setupSwaggerDocs } from './docs/swagger-setup';

const app: Application = express();
const PORT = Number(process.env.PORT) || 3000;

// Security middleware - Enhanced helmet with HSTS
app.use(helmet({
  hsts: {
    maxAge: 31536000,  // 1 year in seconds
    includeSubDomains: true,
    preload: true
  },
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'"],  // Allow inline styles for Swagger UI
      scriptSrc: ["'self'"],
      imgSrc: ["'self'", "data:", "https:"],
    }
  }
}));

// CORS - Require explicit whitelist in production
const allowedOrigins = process.env.ALLOWED_ORIGINS?.split(',').map(o => o.trim());
if (!allowedOrigins || allowedOrigins.length === 0) {
  if (process.env.NODE_ENV === 'production') {
    logger.error('ALLOWED_ORIGINS must be configured in production');
    process.exit(1);
  }
  // Development fallback
  logger.warn('ALLOWED_ORIGINS not set - allowing all origins (development only)');
}

app.use(cors({
  origin: (origin, callback) => {
    // Allow requests with no origin (mobile apps, Postman, curl)
    if (!origin) return callback(null, true);
    
    // In development, allow all if ALLOWED_ORIGINS not set
    if (!allowedOrigins && process.env.NODE_ENV !== 'production') {
      return callback(null, true);
    }
    
    if (allowedOrigins && allowedOrigins.includes(origin)) {
      callback(null, true);
    } else {
      logger.warn(`Blocked CORS request from origin: ${origin}`);
      callback(new Error('Not allowed by CORS'));
    }
  },
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization', 'Cache-Control', 'Pragma'],
  exposedHeaders: ['Content-Length', 'Content-Type'],
  maxAge: 86400 // 24 hours
}));

// Rate limiting - Adjusted for realistic production load
// Changed from 100/15min (0.11 RPS) to 60/min (1 RPS) based on load testing
const globalLimiter = rateLimit({
  windowMs: 60 * 1000, // 1 minute (was 15 minutes)
  max: process.env.NODE_ENV === 'production' ? 60 : 1000, // 60/min in production (was 100/15min)
  standardHeaders: true,
  legacyHeaders: false,
  message: 'Too many requests from this IP, please try again later.',
  handler: (req, res) => {
    logger.warn('Rate limit exceeded', { ip: req.ip, path: req.path });
    res.status(429).json({
      error: 'Too Many Requests',
      message: 'Rate limit exceeded. Please try again later.'
    });
  }
});
app.use('/api', globalLimiter);

// Strict rate limiting for authentication endpoints
export const authLimiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 5, // Only 5 login attempts per 15 minutes
  skipSuccessfulRequests: true,
  message: 'Too many login attempts, please try again later.'
});

// Body parsing - Reduced limit for security
app.use(express.json({ limit: '2mb' }));
app.use(express.urlencoded({ extended: true, limit: '2mb' }));

// Logging
app.use(morgan('combined', { stream: { write: (message) => logger.info(message.trim()) } }));

// Performance monitoring
app.use(performanceMiddleware);

// API Documentation (Swagger UI) - before authentication
setupSwaggerDocs(app);

// Health check
app.get('/health', (req: Request, res: Response) => {
  res.status(200).json({
    status: 'healthy',
    timestamp: new Date().toISOString(),
    service: 'api-gateway',
    version: '1.0.0'
  });
});

// Public routes (no authentication required)
import downloadsRoutes from './routes/downloads';
import telemetryRoutes from './routes/telemetry';
import agentsRoutes from './routes/agents';
app.use('/api/downloads', downloadsRoutes);
app.use('/api/telemetry', telemetryRoutes);
app.use('/api/agents', agentsRoutes);

// Authentication middleware for protected routes
app.use('/api', authMiddleware);

// Routes
app.use('/api', routes);

// 404 handler
app.use((req: Request, res: Response) => {
  res.status(404).json({
    error: 'Not Found',
    message: `Route ${req.method} ${req.path} not found`
  });
});

// Error handling
app.use(errorHandler);

// Start server - bind to 0.0.0.0 to allow external connections
app.listen(PORT, '0.0.0.0', () => {
  logger.info(`ðŸš€ API Gateway running on port ${PORT}`);
  logger.info(`ðŸŒ¸ IAC Dharma - Balance in Automation`);
});

export default app;
